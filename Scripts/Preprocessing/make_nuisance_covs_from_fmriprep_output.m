% this function takes a confounds file generated by fmriprep, selects some 
% desired regressors, and computes and adds some other desired regressors.
% It returns a matrix of all possible nuisance regressors, as well as a 
% matrix of a reasonable subset of regressors decided up on in lab mtg -- see below.
%
% This function also saves the output back to the fmriprep confounds file,
% so they can stay with the dataset. If the regressors it is looking for
% are already in the fmriprep confounds file, this script assumes this function was already
% run and so it does not regenerate them, and just returns what was in the
% file.
%
% in a Jan 2019 Wager lab mtg, we decided that its sensible to include the
% following in a 1st level model for task data: 24 motion regressors, CSF
% (esp. a degraded/conservative CSF mask), canlab spike detection on the
% raw data, spikes for initial volumes (5 sec), spikes as determined by DVARS / RMSQ (Zscore > 2.5), framewise displacement.  We decided _not_ to
% include WM signal, as this often can contain BOLD signal of neuronal
% origin.  -- Yoni Ashar

function [Rfull, Rselected] = make_nuisance_covs_from_fmriprep_output(fmriprep_confounds_fname, raw_img_fname, TR)

confound_fname_csv = [fmriprep_confounds_fname(1:end-3) 'csv']; % replace tsv with csv
copyfile(fmriprep_confounds_fname, confound_fname_csv); % dumb hack to appease matlab -- readtable will only work with .csv, not .tsv
R = readtable(confound_fname_csv, 'TreatAsEmpty', 'n/a');

% replace NaNs in first row with Os
wh_replace = ismissing(R(1,:));
if any(wh_replace)
    R{1, wh_replace} = zeros(1, sum(wh_replace)); 
end


% compute 24 motion regs
mot_names = {'trans_x','trans_y','trans_z','rot_x','rot_y','rot_z'};
motion = R{:,mot_names};
diffs = [zeros(1,6); diff(motion)];
mo_sq = motion .^ 2;
mo_sq_diff = [zeros(1,6); diff(mo_sq)];
motion18 = [diffs mo_sq mo_sq_diff];

mot_names18 = [cellfun( @(x) [x '_diff'], mot_names, 'UniformOutput',false) cellfun( @(x) [x '_sq'], mot_names, 'UniformOutput',false) cellfun( @(x) [x '_sq_diff'], mot_names, 'UniformOutput',false) ];

motion18 = array2table(motion18, 'VariableNames', mot_names18);
%head(motion18)
    
% remove previously saved motion cols 1) in case there was an error, and 2)
% so i can re-add them without conflict
R(:,contains(R.Properties.VariableNames, 'diff')) = [];
R(:,contains(R.Properties.VariableNames, 'sq')) = [];

% add them in
R = [R motion18];


% add spikes for initial volumes. can "redo" this if already exists; not a
% problem
nvols = round(5/TR);  % first 5 seconds
R.initial_vols = zeros(height(R),1);
R.initial_vols(1:nvols) = ones(nvols,1);

% find spike cols
spike_cols = contains(R.Properties.VariableNames,'nuisance_covs'); 

if sum(spike_cols) == 0 % have not yet computed and added these

    % add in canlab spike detection (Mahalanobis distance)
    [g, spikes, gtrim, nuisance_covs, snr] = scn_session_spike_id(raw_img_fname, 'doplot', 0);

    nuisance_covs = nuisance_covs{1};
    nuisance_covs(:,1) = []; %drop gtrim 
    R = [R array2table(nuisance_covs)];

    % find updated spike cols
    spike_cols = contains(regs,'nuisance_covs'); 

end


% make spike regs from dvars. we dont expect a reliable signal in the brain
% that tracks dvars, so less sensible to include as a parametric regressor.
% better to use to identify outliers
dvarsZ = [ 0; zscore(R.dvars(2:end))]; % first element of dvars always = 0, drop it from zscoring and set it to Z=0
dvars_spikes = find(dvarsZ > 2.5); % arbitrary cutoff -- Z > 2.5

% make regs from spike indices
dvars_spikes_regs = zeros(height(R),length(dvars_spikes));
for i=1:length(dvars_spikes)
    dvars_spikes_regs(dvars_spikes(i),i) = 1;
end

% plot: compare dvars spikes to mahal spikes
create_figure('spikes'); imagesc([sum(dvars_spikes_regs, 2) sum(R{:,spike_cols},2)])
set(gca, 'XTick', 1:2,'XTickLabel', {'Dvars spikes', 'Mahal spikes'})%, 'Position', [600 400 450 550])
ylabel('TRs')

% find dvars_spike_regs that are non-redundant with mahal spikes, and
% include them. compare TRs at which spike happens
same = ismember(dvars_spikes, find(sum(R{:,spike_cols},2)));
dvars_spikes_regs(:,same) = []; % drop the redundant ones

% remove any previous dvars_spikes_regs, and add the ones i just made
dvars_cols = contains(R.Properties.VariableNames,'dvars_spikes'); 
R(:,dvars_cols) = [];
dvars_spikes_regs = array2table(dvars_spikes_regs);
R = [R dvars_spikes_regs];

% Select reasonable subset of regressors
regs = R.Properties.VariableNames;
dvars_cols = contains(regs,'dvars_spikes'); 
spike_cols = contains(regs,'nuisance_covs'); 
motion_cols = contains(regs,'rot') | contains(regs,'trans') | contains(regs,'diff'); 

Rselected = R(:,motion_cols | spike_cols | dvars_cols);
Rselected.framewise_displacement = R.framewise_displacement;
Rselected.csf = R.csf;

% write back to file
writetable(R, confound_fname_csv);
movefile(confound_fname_csv, fmriprep_confounds_fname); % revert to .tsv to appease BIDS spec

Rfull = R;

end