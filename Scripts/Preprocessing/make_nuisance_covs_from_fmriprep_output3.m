% this function takes a confounds file generated by fmriprep for one run
% and creates a nuisance covariate matrix with the following regressors:
%
% 1) spikes for framewise displacement > .25mm. Note that Head Motion Parameter Estimates (HMPs) are filtered
%    according to Power 2019 and back-computed to ~2 seconds back, vs. 1 frame back
% 2) spikes for DVARS z-score > 3
% 3) spikes for the n volumes following the volumes identified in #1 and #2 above. n = spike_additional_vols
%    about 2 sec worth is recommended.
% 4) 24 motion covs (based on unfiltered HMPs): HMPs, diff(HMPs), squared HMPs, squared diffs
% 5) fmriprep global CSF
% 6) fmriprep global Global Signal (not always used in CANlab)
%
% Note: 3 streams:
% fmriprep output -> dVars -> dvars_spikes (current and subsequent)
% motion -> squares, etc. -> motion24 (24 continuous regressors per run)
% motion -> filtFD/framewise disp -> FD5_spikes (current and subsequent)
%
% ndummies: how many initial vols to drop from the cov matrix (assuming
% these volumes get dropped from fMRI data too)
%
% output: the nuisance covariate matrix defined above, how many spikes
% detected, and what % of vols flagged as spikes
%
% Note: Variables and labels must be as specified in fmriprep output circa
% 2020.  Check and verify that it's working for you!
%
% -- Yoni Ashar



function [nuis_matrix, n_spike_regs, n_spike_regs_percent] = make_nuisance_covs_from_fmriprep_output3(fmriprep_confounds_fname, TR, spike_additional_vols, ndummies)

R = readtable(fmriprep_confounds_fname, 'TreatAsEmpty', 'n/a', 'filetype', 'text');

R = R(ndummies+1:end,:);

% compute 24 motion regs
mot_names = {'trans_x','trans_y','trans_z','rot_x','rot_y','rot_z'};
motion = R{:,mot_names};
diffs = [zeros(1,6); diff(motion)];
mo_sq = motion .^ 2;
mo_sq_diff = [zeros(1,6); diff(mo_sq)];
motion24 = [motion diffs mo_sq mo_sq_diff];



% --- DEFINE OUTLIERS / SPIKES --- %

% FD-based spikes. First, compute FD following Power 2019
motion(:,4:6) = (motion(:,4:6) / (2*pi)) * 100 * pi; % fraction of circle (radians / 2pi) * diameter (pi*d).   convert rotation to mm. assume head is 50mm sphere (Power et al 2012)
fd_5TRs = filtFD(motion, TR);

% define spikes based off FD
FD5_spikes = fd_5TRs > .25;

% DVARS based spikes -- Z > 3. Omit first vol and replace w/ 0 (=unflagged)
dvars_spikes = [0; zscore(R.dvars(2:end)) > 3];

% combine all my spikes
allspikes = FD5_spikes | dvars_spikes; 

% add additional spike vols for vols following the spike. If
% spike_additional_vols is zero, nothing happens, as desired.
origspikes = find(allspikes);

for i=1:spike_additional_vols
    
    if origspikes+i < length(allspikes) % dont make a spike past the end
        allspikes(origspikes+i) = 1;
    end
    
end

% make into 0/1 spike regressors
allspikes = find(allspikes);
spikes_regs = zeros(height(R), length(allspikes));

for i=1:length(allspikes)
    spikes_regs(allspikes(i),i) = 1;
end

% -- CREATE NUIS MATRIX W/ MOTION, SPIKES, CSF, GS
% note that GS is from within the brain mask, as computed w/ fMRIprep
nuis_matrix = [motion24 spikes_regs zscore(R.csf) zscore(R.global_signal)];

% compute and output how many spikes total
n_spike_regs = length(allspikes)
n_spike_regs_percent = n_spike_regs / height(R)


end


% filters out pseudomotion freq from HMPs (see Power et al 2019) and
% computes FD wrt to about 2 sec prev
function [fd, motion6] = filtFD(motion6, TR)

    % filter all the HMPs
    nyq = (1/TR)/2;
    stopband = [.1 .5];
    [B, A] = butter(10, stopband/nyq, 'stop');

    for i=1:6
        motion6(:,i) = filtfilt(B,A,motion6(:,i));
    end

    % compute how many vols previous will equal 2-3 sec time lag -- See
    % Power et al 2019
    diff_distance = ceil(2/TR);
    
    % compute diffs wrt to 5 vols previous
    diffs = motion6 - circshift(motion6, diff_distance); % this is incorrect for the initial vols; set to zero on next line
    diffs(1:diff_distance, :) = 0;
    
    fd = sum(abs(diffs),2);
    
end
